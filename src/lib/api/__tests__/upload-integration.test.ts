import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { renderHook, act, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useDocumentUpload } from '@/hooks/queries/documents.queries'
import { useSubscription } from '@/hooks/use-subscription'
import { apiClient } from '@/lib/api/client'
import type { Document, UploadOptions } from '@/types'
import type { PropsWithChildren } from 'react'

// Setup MSW for more realistic API mocking
import { setupServer } from 'msw/node'
import { http, HttpResponse, delay } from 'msw'

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080'

// Mock document response
const createMockDocument = (overrides?: Partial<Document>): Document => ({
  id: 'doc-123',
  title: 'test-document.pdf',
  filename: 'test-document.pdf',
  file_path: '/uploads/test-document.pdf',
  content_type: 'application/pdf',
  file_size: 1024,
  document_type: 'document',
  tenant_id: 'tenant-123',
  user_id: 'user-123',
  ai_processed: false,
  embedding_status: 'pending',
  status: 'uploaded',
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
  ...overrides,
})

// MSW handlers
const handlers = [
  http.post(`${API_URL}/api/v1/documents/upload`, async ({ request }) => {
    // Simulate upload delay
    await delay(100)

    // Parse form data
    const formData = await request.formData()
    const file = formData.get('file') as File
    const enableAI = formData.get('enable_ai') === 'true'
    const enableOCR = formData.get('enable_ocr') === 'true'

    // Simulate different responses based on file
    if (file.name.includes('error')) {
      return HttpResponse.json(
        { message: 'Upload failed' },
        { status: 500 }
      )
    }

    if (file.name.includes('quota')) {
      return HttpResponse.json(
        { 
          message: 'Document quota exceeded',
          code: 'QUOTA_EXCEEDED',
          details: { used: 100, limit: 100, feature: 'documents' }
        },
        { status: 402 }
      )
    }

    // Return processing document if AI is enabled
    const status = enableAI ? 'processing' : 'uploaded'
    const aiProcessingStatus = enableAI ? 'pending' : undefined

    return HttpResponse.json(
      createMockDocument({
        id: `doc-${Date.now()}`,
        title: formData.get('title') as string || file.name,
        filename: file.name,
        file_size: file.size,
        status,
        ai_processing_status: aiProcessingStatus,
        ai_processed: false,
        embedding_status: enableAI ? 'pending' : 'completed',
      })
    )
  }),

  http.get(`${API_URL}/api/v1/documents/:id`, async ({ params }) => {
    await delay(50)
    
    // Simulate document processing progress
    const docId = params.id as string
    
    // First request: processing
    if (!global.processedDocs?.has(docId)) {
      global.processedDocs = global.processedDocs || new Set()
      global.processedDocs.add(docId)
      
      return HttpResponse.json(
        createMockDocument({
          id: docId,
          status: 'processing',
          ai_processing_status: 'processing',
          embedding_status: 'processing',
        })
      )
    }

    // Subsequent requests: completed
    return HttpResponse.json(
      createMockDocument({
        id: docId,
        status: 'ai_processed',
        ai_processed: true,
        ai_processing_status: 'completed',
        embedding_status: 'completed',
        ai_summary: 'This is a test document summary generated by AI.',
        ai_entities: ['Entity1', 'Entity2'],
        ai_key_points: ['Key point 1', 'Key point 2'],
        ai_confidence_score: 0.95,
      })
    )
  }),

  http.get(`${API_URL}/api/v1/subscription/check-quota`, async ({ request }) => {
    const url = new URL(request.url)
    const feature = url.searchParams.get('feature')
    
    if (feature === 'documents') {
      return HttpResponse.json({
        allowed: true,
        used: 50,
        limit: 100,
        remaining: 50,
        percentage: 50,
      })
    }
    
    return HttpResponse.json({ allowed: true })
  }),
]

const server = setupServer(...handlers)

describe('Document Upload Integration Tests', () => {
  let queryClient: QueryClient

  const wrapper = ({ children }: PropsWithChildren) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )

  beforeEach(() => {
    server.listen({ onUnhandledRequest: 'error' })
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false, gcTime: 0 },
        mutations: { retry: false },
      },
    })
    global.processedDocs = new Set()
  })

  afterEach(() => {
    server.resetHandlers()
    queryClient.clear()
  })

  afterAll(() => {
    server.close()
  })

  describe('Complete Upload Flow', () => {
    it('should handle complete upload flow with AI processing', async () => {
      const { result: uploadHook } = renderHook(() => useDocumentUpload(), { wrapper })
      
      const file = new File(['test content'], 'important-document.pdf', {
        type: 'application/pdf',
      })

      const options: UploadOptions = {
        enable_ai: true,
        enable_ocr: true,
        folder_id: 'folder-123',
        tags: ['important', '2024'],
      }

      let uploadedDocument: Document | null = null

      // Step 1: Upload document
      await act(async () => {
        uploadedDocument = await uploadHook.current.mutateAsync({
          file,
          options,
        })
      })

      expect(uploadedDocument).toBeTruthy()
      expect(uploadedDocument!.status).toBe('processing')
      expect(uploadedDocument!.ai_processing_status).toBe('pending')

      // Step 2: Check processing status
      const { result: documentHook } = renderHook(
        () => apiClient.getDocument(uploadedDocument!.id),
        { wrapper }
      )

      // First check - still processing
      const processingDoc = await documentHook.current
      expect(processingDoc.status).toBe('processing')

      // Wait and check again - should be completed
      await waitFor(async () => {
        const completedDoc = await apiClient.getDocument(uploadedDocument!.id)
        expect(completedDoc.status).toBe('ai_processed')
        expect(completedDoc.ai_processed).toBe(true)
        expect(completedDoc.ai_summary).toBeDefined()
        expect(completedDoc.ai_entities).toHaveLength(2)
        expect(completedDoc.ai_confidence_score).toBe(0.95)
      })
    })

    it('should handle upload without AI processing', async () => {
      const { result } = renderHook(() => useDocumentUpload(), { wrapper })
      
      const file = new File(['test content'], 'simple-document.pdf', {
        type: 'application/pdf',
      })

      const options: UploadOptions = {
        enable_ai: false,
        enable_ocr: false,
      }

      const uploadedDocument = await result.current.mutateAsync({
        file,
        options,
      })

      expect(uploadedDocument.status).toBe('uploaded')
      expect(uploadedDocument.ai_processing_status).toBeUndefined()
      expect(uploadedDocument.embedding_status).toBe('completed')
    })

    it('should handle quota exceeded errors', async () => {
      const { result } = renderHook(() => useDocumentUpload(), { wrapper })
      
      const file = new File(['test content'], 'quota-exceeded.pdf', {
        type: 'application/pdf',
      })

      await expect(
        result.current.mutateAsync({ file })
      ).rejects.toMatchObject({
        response: {
          status: 402,
          data: expect.objectContaining({
            code: 'QUOTA_EXCEEDED',
          }),
        },
      })
    })

    it('should handle server errors gracefully', async () => {
      const { result } = renderHook(() => useDocumentUpload(), { wrapper })
      
      const file = new File(['test content'], 'error-document.pdf', {
        type: 'application/pdf',
      })

      await expect(
        result.current.mutateAsync({ file })
      ).rejects.toMatchObject({
        response: {
          status: 500,
          data: { message: 'Upload failed' },
        },
      })
    })
  })

  describe('Batch Upload Flow', () => {
    it('should handle multiple file uploads', async () => {
      const { result } = renderHook(() => useDocumentUpload(), { wrapper })
      
      const files = [
        new File(['content1'], 'doc1.pdf', { type: 'application/pdf' }),
        new File(['content2'], 'doc2.pdf', { type: 'application/pdf' }),
        new File(['content3'], 'doc3.pdf', { type: 'application/pdf' }),
      ]

      const uploadResults: Document[] = []

      // Upload files sequentially
      for (const file of files) {
        const doc = await result.current.mutateAsync({
          file,
          options: { enable_ai: true },
        })
        uploadResults.push(doc)
      }

      expect(uploadResults).toHaveLength(3)
      expect(uploadResults.every(doc => doc.status === 'processing')).toBe(true)
      expect(new Set(uploadResults.map(doc => doc.id)).size).toBe(3) // All unique IDs
    })
  })

  describe('Progress Tracking', () => {
    it('should track upload progress', async () => {
      const { result } = renderHook(() => useDocumentUpload(), { wrapper })
      
      const file = new File(['x'.repeat(1024 * 1024)], 'large-file.pdf', {
        type: 'application/pdf',
      })

      const progressValues: number[] = []
      const onProgress = (progress: number) => {
        progressValues.push(progress)
      }

      await result.current.mutateAsync({
        file,
        onProgress,
      })

      // Progress tracking is handled by axios, so we can't easily test it
      // in integration tests without more complex mocking
      expect(true).toBe(true) // Placeholder assertion
    })
  })

  describe('File Type Support', () => {
    const fileTypes = [
      { name: 'document.pdf', type: 'application/pdf' },
      { name: 'document.docx', type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' },
      { name: 'data.json', type: 'application/json' },
      { name: 'spreadsheet.xlsx', type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' },
      { name: 'image.png', type: 'image/png' },
      { name: 'presentation.pptx', type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' },
    ]

    fileTypes.forEach(({ name, type }) => {
      it(`should upload ${name} successfully`, async () => {
        const { result } = renderHook(() => useDocumentUpload(), { wrapper })
        
        const file = new File(['content'], name, { type })
        
        const uploadedDocument = await result.current.mutateAsync({ file })
        
        expect(uploadedDocument.filename).toBe(name)
        expect(uploadedDocument.content_type).toBe(type)
      })
    })
  })
})